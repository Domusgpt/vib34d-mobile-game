<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VIB34D Portal Viewer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body { 
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 50%, #0f0f0f 100%);
            color: #fff; 
            font-family: 'Orbitron', monospace;
            overflow: hidden;
            perspective: 2000px;
            position: relative;
        }

        /* Dark Silicon Glass Background with Grid */
        :root {
            --bg-offset-x: 0px;
            --bg-offset-y: 0px;
            --tilt-intensity: 0;
        }
        
        .silicon-background {
            position: fixed;
            top: -100px; left: -100px; right: -100px; bottom: -100px; /* Oversized for parallax */
            background: 
                radial-gradient(circle at 20% 30%, rgba(0, 255, 255, 0.03) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(255, 0, 255, 0.03) 0%, transparent 50%),
                linear-gradient(135deg, #0a0a0a 0%, #1a1a2a 30%, #0f0f1f 70%, #0a0a0a 100%);
            backdrop-filter: blur(1px);
            z-index: -2;
            /* Parallax movement based on tilt */
            transform: translate(var(--bg-offset-x), var(--bg-offset-y));
            transition: transform 0.1s ease-out;
        }

        .silicon-background::before {
            content: '';
            position: absolute;
            top: -50px; left: -50px; right: -50px; bottom: -50px; /* Oversized for parallax */
            background-image: 
                linear-gradient(rgba(0, 255, 255, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 255, 0.05) 1px, transparent 1px);
            background-size: 50px 50px;
            animation: gridShift 20s linear infinite;
            z-index: -1;
            /* Double parallax for grid layer */
            transform: translate(calc(var(--bg-offset-x) * 1.5), calc(var(--bg-offset-y) * 1.5));
        }

        @keyframes gridShift {
            0% { background-position: 0 0; }
            100% { background-position: 50px 50px; }
        }

        /* Main Portal Container */
        .portal-viewer {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            transform-style: preserve-3d;
        }

        /* Portal Window */
        .visualization-portal {
            position: relative;
            width: 85vw;
            height: 85vh;
            max-width: 1200px;
            max-height: 800px;
            border-radius: 20px;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(0, 255, 255, 0.3);
            box-shadow: 
                0 0 50px rgba(0, 255, 255, 0.2),
                0 0 100px rgba(255, 0, 255, 0.1),
                inset 0 0 50px rgba(0, 0, 0, 0.5);
            transition: all 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            transform-style: preserve-3d;
            overflow: hidden;
            cursor: pointer;
        }

        .visualization-portal:hover {
            transform: scale(1.08) translateZ(30px);
            border-color: rgba(0, 255, 255, 0.6);
            box-shadow: 
                0 0 80px rgba(0, 255, 255, 0.4),
                0 0 150px rgba(255, 0, 255, 0.2),
                inset 0 0 30px rgba(0, 0, 0, 0.3);
        }

        /* RGB Flash Effect */
        .visualization-portal::after {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(
                calc(45deg + (var(--mouse-x, 50) - 50) * 1.2deg),
                transparent 15%,
                rgba(0, 255, 255, 0.2) 40%,
                rgba(255, 0, 255, 0.25) 50%,
                rgba(255, 100, 0, 0.2) 60%,
                transparent 85%
            );
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            border-radius: 18px;
            mix-blend-mode: screen;
        }

        .visualization-portal:hover::after {
            opacity: 1;
        }

        /* Canvas Container */
        .canvas-container {
            position: relative;
            width: 100%;
            height: 100%;
            border-radius: 18px;
            overflow: hidden;
        }

        /* VIB34D Engine Canvases */
        .engine-canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%;
            height: 100%;
            border-radius: 18px;
        }

        /* Audio Toggle (Top Right) */
        .audio-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid rgba(0, 255, 255, 0.3);
            color: #00ffff;
            padding: 12px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-family: 'Orbitron', monospace;
            font-size: 14px;
            transition: all 0.3s ease;
            z-index: 100;
        }

        .audio-toggle:hover {
            background: rgba(0, 255, 255, 0.1);
            border-color: rgba(0, 255, 255, 0.6);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }

        .audio-toggle.active {
            background: rgba(0, 255, 255, 0.2);
            border-color: rgba(0, 255, 255, 0.8);
            color: #ffffff;
        }
        
        .control-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 15px;
            border: 2px solid rgba(0, 255, 255, 0.3);
            backdrop-filter: blur(10px);
        }

        /* Minimal Info Display */
        .info-display {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(0, 255, 255, 0.3);
            padding: 15px 20px;
            border-radius: 15px;
            font-size: 12px;
            backdrop-filter: blur(5px);
            z-index: 100;
            font-family: 'Orbitron', monospace;
        }

        .info-display h3 {
            margin: 0 0 8px 0;
            color: #00ffff;
            font-size: 14px;
        }

        .info-display p {
            margin: 3px 0;
            color: #ccc;
        }

        /* Mobile Optimizations */
        @media (max-width: 768px) {
            .visualization-portal {
                width: 95vw;
                height: 85vh;
                border-radius: 15px;
            }
            
            .audio-toggle {
                top: 15px;
                right: 15px;
                padding: 10px 16px;
                font-size: 12px;
            }
            
            .info-display {
                bottom: 15px;
                left: 15px;
                padding: 12px 15px;
                font-size: 11px;
            }
        }

        /* Loading State */
        .loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #00ffff;
            font-size: 18px;
            text-align: center;
            z-index: 10;
        }

        .loading::after {
            content: '';
            display: inline-block;
            width: 20px;
            height: 20px;
            margin-left: 10px;
            border: 2px solid transparent;
            border-top: 2px solid #00ffff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="silicon-background"></div>
    
    <div class="portal-viewer">
        <div class="visualization-portal" id="portalWindow">
            <div class="canvas-container">
                <!-- VIB34D Engine Canvas Layers -->
                <canvas id="background-canvas" class="engine-canvas"></canvas>
                <canvas id="shadow-canvas" class="engine-canvas"></canvas>
                <canvas id="content-canvas" class="engine-canvas"></canvas>
                <canvas id="highlight-canvas" class="engine-canvas"></canvas>
                <canvas id="accent-canvas" class="engine-canvas"></canvas>
                <div class="loading" id="loadingIndicator">Initializing Portal Engine...</div>
            </div>
        </div>
    </div>

    <div class="control-panel">
        <button class="audio-toggle active" id="mouseToggle">üñ±Ô∏è Mouse Reactive</button>
        <button class="audio-toggle active" id="tiltToggle">üì± Device Tilt</button>
        <button class="audio-toggle" id="audioToggle">üéµ Audio Reactive</button>
        <button class="audio-toggle active" id="enhancedToggle">‚ú® Enhanced FX</button>
    </div>
    
    <div class="info-display" id="infoDisplay">
        <h3>Portal Parameters</h3>
        <p id="systemType">System: Loading...</p>
        <p id="geometryInfo">Geometry: Loading...</p>
        <p id="configInfo">Configuration: Loading...</p>
    </div>

    <script type="module">
        // Import system-specific visualizers from VIB34D engine
        import { IntegratedHolographicVisualizer } from './src/core/Visualizer.js';
        import { QuantumHolographicVisualizer } from './src/quantum/QuantumVisualizer.js';
        import { HolographicVisualizer } from './src/holograms/HolographicVisualizer.js';
        
        class PortalEngine {
            constructor() {
                this.portalWindow = document.getElementById('portalWindow');
                this.loadingIndicator = document.getElementById('loadingIndicator');
                
                this.visualizers = [];
                this.mouseX = 0.5;
                this.mouseY = 0.5;
                this.mouseIntensity = 0.0;
                this.clickIntensity = 0.0;
                
                // Enhanced Interactivity State with 4D perspective mapping
                this.interactivityState = {
                    mouse: true,
                    tilt: true,
                    audio: false,
                    enhanced: true
                };
                
                // 4D rotation perspective base values
                this.baseRotations = {
                    rot4dXW: 0,
                    rot4dYW: 0,
                    rot4dZW: 0
                };
                
                // Device orientation tracking for realistic 4D perspective
                this.deviceOrientation = {
                    alpha: 0,   // Z-axis rotation (compass)
                    beta: 0,    // X-axis rotation (front-to-back tilt)  
                    gamma: 0    // Y-axis rotation (left-to-right tilt)
                };
                this.audioReactive = false;
                this.audioData = null;
                
                // Portal expansion state
                this.isExpanded = false;
                this.tiltX = 0;
                this.tiltY = 0;
                
                // Parameters from URL
                this.params = this.parseUrlParameters();
                
                // Store base 4D rotations from URL parameters
                this.baseRotations.rot4dXW = this.params.rot4dXW;
                this.baseRotations.rot4dYW = this.params.rot4dYW;
                this.baseRotations.rot4dZW = this.params.rot4dZW;
                
                this.updateInfoDisplay();
                
                this.init();
            }
            
            async init() {
                try {
                    await this.setupCanvases();
                    await this.createEngineVisualizers();
                    this.setupPortalInteractions();
                    this.setupEventHandlers();
                    
                    this.loadingIndicator.style.display = 'none';
                    this.startRenderLoop();
                    
                    console.log('üé® Portal engine initialized with VIB34D visualizers');
                } catch (error) {
                    console.error('‚ùå Portal engine initialization failed:', error);
                    this.loadingIndicator.textContent = 'Failed to initialize portal engine';
                }
            }
            
            async setupCanvases() {
                const rect = this.portalWindow.getBoundingClientRect();
                const dpr = Math.min(window.devicePixelRatio || 1, 2);
                
                const canvases = ['background-canvas', 'shadow-canvas', 'content-canvas', 'highlight-canvas', 'accent-canvas'];
                
                canvases.forEach(canvasId => {
                    const canvas = document.getElementById(canvasId);
                    if (canvas) {
                        canvas.width = rect.width * dpr;
                        canvas.height = rect.height * dpr;
                        canvas.style.width = rect.width + 'px';
                        canvas.style.height = rect.height + 'px';
                    }
                });
            }
            
            async createEngineVisualizers() {
                // Create system-specific visualizers based on URL system parameter
                console.log(`üîç Creating visualizers for system: ${this.params.system}`);
                
                const layers = [
                    { id: 'background-canvas', role: 'background', reactivity: 0.5, variant: 0 },
                    { id: 'shadow-canvas', role: 'shadow', reactivity: 0.7, variant: 1 },
                    { id: 'content-canvas', role: 'content', reactivity: 0.9, variant: 2 },
                    { id: 'highlight-canvas', role: 'highlight', reactivity: 1.1, variant: 3 },
                    { id: 'accent-canvas', role: 'accent', reactivity: 1.5, variant: 4 }
                ];
                
                let successfulLayers = 0;
                
                for (const layer of layers) {
                    try {
                        const canvas = document.getElementById(layer.id);
                        if (!canvas) {
                            console.error(`‚ùå Canvas not found: ${layer.id}`);
                            continue;
                        }
                        
                        console.log(`üîç Creating ${this.params.system} visualizer for: ${layer.id}`);
                        let visualizer;
                        
                        // Create system-specific visualizer
                        switch (this.params.system) {
                            case 'quantum':
                                visualizer = new QuantumHolographicVisualizer(layer.id, layer.role, layer.reactivity, layer.variant);
                                break;
                            case 'holographic':
                                visualizer = new HolographicVisualizer(layer.id, layer.role, layer.reactivity, layer.variant);
                                break;
                            case 'faceted':
                            default:
                                visualizer = new IntegratedHolographicVisualizer(layer.id, layer.role, layer.reactivity, layer.variant);
                                break;
                        }
                        
                        if (visualizer && visualizer.gl) {
                            // Apply current parameters to visualizer
                            this.applyParametersToVisualizer(visualizer);
                            
                            this.visualizers.push(visualizer);
                            successfulLayers++;
                            console.log(`‚úÖ Created ${this.params.system} layer: ${layer.role} (${layer.id})`);
                        } else {
                            console.error(`‚ùå No WebGL context for: ${layer.id}`);
                        }
                    } catch (error) {
                        console.error(`‚ùå Failed to create ${this.params.system} layer ${layer.id}:`, error);
                    }
                }
                
                console.log(`‚úÖ Created ${successfulLayers}/5 ${this.params.system} engine layers`);
            }
            
            applyParametersToVisualizer(visualizer) {
                // Apply URL parameters to the visualizer using consistent parameter names
                if (visualizer.updateParameters) {
                    const standardParams = {
                        geometry: this.params.geometryType,
                        gridDensity: this.params.density,
                        morphFactor: this.params.morph,
                        chaos: this.params.chaos,
                        speed: this.params.speed,
                        hue: this.params.hue,
                        intensity: this.params.intensity,
                        saturation: this.params.saturation,
                        rot4dXW: this.params.rot4dXW,
                        rot4dYW: this.params.rot4dYW,
                        rot4dZW: this.params.rot4dZW
                    };
                    
                    console.log(`üîß Applying parameters to ${this.params.system} visualizer:`, standardParams);
                    visualizer.updateParameters(standardParams);
                } else if (visualizer.setParameters) {
                    // Alternative parameter setting method
                    visualizer.setParameters({
                        geometry: this.params.geometryType,
                        gridDensity: this.params.density,
                        morphFactor: this.params.morph,
                        chaos: this.params.chaos,
                        speed: this.params.speed,
                        hue: this.params.hue,
                        intensity: this.params.intensity,
                        saturation: this.params.saturation
                    });
                } else {
                    console.warn(`‚ö†Ô∏è No parameter setting method found for ${this.params.system} visualizer`);
                }
            }
            
            setupPortalInteractions() {
                // Enhanced mouse tracking for portal expansion and tilt effects
                this.portalWindow.addEventListener('mousemove', (e) => {
                    const rect = this.portalWindow.getBoundingClientRect();
                    this.mouseX = (e.clientX - rect.left) / rect.width;
                    this.mouseY = 1 - (e.clientY - rect.top) / rect.height;
                    
                    // Calculate tilt based on mouse position (more dramatic when expanded)
                    const centerX = rect.width / 2;
                    const centerY = rect.height / 2;
                    const maxTilt = this.isExpanded ? 25 : 10; // More tilt when expanded
                    
                    this.tiltX = ((e.clientX - rect.left - centerX) / centerX) * maxTilt;
                    this.tiltY = ((e.clientY - rect.top - centerY) / centerY) * -maxTilt;
                    
                    // Update portal visual tilt
                    this.updatePortalTilt();
                    
                    // Update CSS custom properties for RGB flash
                    document.documentElement.style.setProperty('--mouse-x', this.mouseX * 100);
                    document.documentElement.style.setProperty('--mouse-y', this.mouseY * 100);
                    
                    // Update engine mouse reactivity
                    this.updateEngineReactivity();
                    
                    // Enhanced: Mouse movement affects 4D perspective like looking around
                    if (this.interactivityState.mouse && this.interactivityState.enhanced) {
                        this.updateMouse4DPerspective();
                    }
                });
                
                // Portal expansion on hover
                this.portalWindow.addEventListener('mouseenter', () => {
                    this.isExpanded = true;
                    this.mouseIntensity = 1.0;
                });
                
                this.portalWindow.addEventListener('mouseleave', () => {
                    this.isExpanded = false;
                    this.mouseIntensity = 0.0;
                    this.tiltX = 0;
                    this.tiltY = 0;
                    this.updatePortalTilt();
                });
                
                // Click effects
                this.portalWindow.addEventListener('mousedown', () => {
                    this.clickIntensity = 1.0;
                });
                
                this.portalWindow.addEventListener('mouseup', () => {
                    this.clickIntensity = 0.0;
                });
            }
            
            updatePortalTilt() {
                // Portal tilt is now handled by update4DPerspective and updateMouse4DPerspective
                // This function is kept for compatibility but delegates to the new system
                if (this.interactivityState.mouse && this.interactivityState.enhanced) {
                    this.updateMouse4DPerspective();
                }
            }
            
            updateEngineReactivity() {
                // Update all visualizers with current mouse state
                this.visualizers.forEach(visualizer => {
                    if (visualizer.updateMouse) {
                        visualizer.updateMouse(this.mouseX, this.mouseY, this.mouseIntensity);
                    }
                    if (visualizer.updateClick) {
                        visualizer.updateClick(this.clickIntensity);
                    }
                });
            }
            
            setupEventHandlers() {
                // Enhanced interactivity toggles
                document.getElementById('mouseToggle').addEventListener('click', () => {
                    this.toggleInteractivity('mouse');
                });
                
                document.getElementById('tiltToggle').addEventListener('click', () => {
                    this.toggleInteractivity('tilt');
                });
                
                document.getElementById('audioToggle').addEventListener('click', () => {
                    this.toggleInteractivity('audio');
                });
                
                document.getElementById('enhancedToggle').addEventListener('click', () => {
                    this.toggleInteractivity('enhanced');
                });
                
                // Window resize
                window.addEventListener('resize', () => {
                    this.setupCanvases();
                });
                
                // Keyboard shortcuts
                window.addEventListener('keydown', (e) => {
                    if (e.key === 'f' || e.key === 'F') {
                        this.toggleFullscreen();
                    }
                });
                
                // Device orientation for mobile tilt
                if (window.DeviceOrientationEvent) {
                    window.addEventListener('deviceorientation', (e) => {
                        if (this.interactivityState.tilt) {
                            this.handleDeviceOrientation(e);
                        }
                    });
                }
            }
            
            toggleInteractivity(type) {
                this.interactivityState[type] = !this.interactivityState[type];
                const button = document.getElementById(`${type}Toggle`);
                const isActive = this.interactivityState[type];
                
                if (isActive) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
                
                // Handle specific interactivity types
                switch (type) {
                    case 'audio':
                        if (isActive) {
                            button.textContent = 'üéµ Audio ON';
                            this.initAudio();
                        } else {
                            button.textContent = 'üéµ Audio OFF';
                            this.audioReactive = false;
                        }
                        break;
                        
                    case 'mouse':
                        // Mouse reactivity affects portal tilt and visualizer interaction
                        button.textContent = isActive ? 'üñ±Ô∏è Mouse ON' : 'üñ±Ô∏è Mouse OFF';
                        break;
                        
                    case 'tilt':
                        // Device tilt affects 4D rotation perspective
                        button.textContent = isActive ? 'üì± Tilt ON' : 'üì± Tilt OFF';
                        if (!isActive) {
                            // Reset to base rotations when tilt is disabled
                            this.update4DPerspective(0, 0, 0);
                        }
                        break;
                        
                    case 'enhanced':
                        // Enhanced effects add extra visual flair
                        button.textContent = isActive ? '‚ú® Enhanced ON' : '‚ú® Enhanced OFF';
                        break;
                }
                
                console.log(`üéÆ ${type} interactivity: ${isActive ? 'ON' : 'OFF'}`);
            }
            
            async initAudio() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    const audioContext = new AudioContext();
                    const source = audioContext.createMediaStreamSource(stream);
                    const analyser = audioContext.createAnalyser();
                    
                    analyser.fftSize = 256;
                    source.connect(analyser);
                    
                    this.audioData = new Uint8Array(analyser.frequencyBinCount);
                    this.audioAnalyser = analyser;
                    
                    console.log('üéµ Audio reactive mode enabled');
                } catch (error) {
                    console.warn('Audio access denied:', error);
                    this.audioReactive = false;
                    document.getElementById('audioToggle').classList.remove('active');
                }
            }
            
            handleDeviceOrientation(event) {
                // Update device orientation tracking
                this.deviceOrientation.alpha = event.alpha || 0;  // Z-axis (compass)
                this.deviceOrientation.beta = event.beta || 0;    // X-axis (front-back tilt)
                this.deviceOrientation.gamma = event.gamma || 0;  // Y-axis (left-right tilt)
                
                // Map device orientation to 4D perspective changes
                this.update4DPerspective(
                    this.deviceOrientation.alpha,
                    this.deviceOrientation.beta,
                    this.deviceOrientation.gamma
                );
            }
            
            update4DPerspective(alpha, beta, gamma) {
                if (!this.interactivityState.tilt) return;
                
                // Normalize device orientation values
                const betaNorm = Math.max(-90, Math.min(90, beta));  // Clamp to -90 to 90
                const gammaNorm = Math.max(-90, Math.min(90, gamma)); // Clamp to -90 to 90
                
                // üéØ PARALLAX BACKGROUND: Move opposite to tilt direction
                // When you tilt right, background moves left (creating depth)
                const bgOffsetX = -gammaNorm * 2;  // Opposite direction, amplified
                const bgOffsetY = -betaNorm * 1.5; // Opposite direction, amplified
                
                // Apply parallax to background (creates window effect)
                document.documentElement.style.setProperty('--bg-offset-x', `${bgOffsetX}px`);
                document.documentElement.style.setProperty('--bg-offset-y', `${bgOffsetY}px`);
                
                // üîÑ COUNTER-ROTATION: Object stays fixed in "world space"
                // When device tilts, we counter-rotate the visualization
                const counterRotateX = -betaNorm * 0.3;  // Opposite of tilt
                const counterRotateY = -gammaNorm * 0.3; // Opposite of tilt
                
                // Apply counter-rotation to portal window (maintains object position)
                this.portalWindow.style.transform = `
                    perspective(1000px)
                    rotateX(${counterRotateX}deg)
                    rotateY(${counterRotateY}deg)
                    scale(${this.isExpanded ? 1.08 : 1.0})
                    translateZ(${this.isExpanded ? 30 : 0}px)
                `;
                
                // üåê SUBTLE 4D PERSPECTIVE: Realistic cross-section changes
                // Very subtle changes to 4D rotation show different "slices"
                const subtle4DScale = 0.1; // Much more subtle than before
                
                // Calculate 4D perspective shifts (like seeing different angles of a tesseract)
                const perspective4D = {
                    // Tilting up/down slightly changes the XW slice we're viewing
                    rot4dXW: this.baseRotations.rot4dXW + (betaNorm * Math.PI / 180 * subtle4DScale),
                    
                    // Tilting left/right slightly changes the YW slice
                    rot4dYW: this.baseRotations.rot4dYW + (gammaNorm * Math.PI / 180 * subtle4DScale),
                    
                    // Rotation changes which ZW projection we see
                    rot4dZW: this.baseRotations.rot4dZW + (alpha * Math.PI / 180 * subtle4DScale * 0.5),
                    
                    // NEW: Morph factor changes slightly based on viewing angle
                    // This simulates how 4D objects look different from different 3D perspectives
                    morphFactor: (this.params.morph || 1) + (Math.abs(betaNorm) + Math.abs(gammaNorm)) * 0.002
                };
                
                // Apply subtle 4D transformations to visualizers
                this.visualizers.forEach(visualizer => {
                    if (visualizer.updateParameters) {
                        visualizer.updateParameters(perspective4D);
                    }
                });
                
                // Visual feedback for tilt intensity
                const tiltIntensity = Math.sqrt(betaNorm*betaNorm + gammaNorm*gammaNorm) / 90;
                document.documentElement.style.setProperty('--tilt-intensity', tiltIntensity);
                
                console.log(`üåê Holographic Window: BG(${bgOffsetX.toFixed(1)}, ${bgOffsetY.toFixed(1)}) | Counter(${counterRotateX.toFixed(1)}¬∞, ${counterRotateY.toFixed(1)}¬∞) | 4D(XW:${perspective4D.rot4dXW.toFixed(3)}, YW:${perspective4D.rot4dYW.toFixed(3)})`);
            }
            
            updateMouse4DPerspective() {
                // Map mouse position to viewing angle (like moving your head)
                const mouseOffsetX = (this.mouseX - 0.5) * 2; // -1 to 1
                const mouseOffsetY = (this.mouseY - 0.5) * 2; // -1 to 1
                
                // üéØ PARALLAX BACKGROUND: Mouse movement creates depth
                const bgMouseX = -mouseOffsetX * 30;  // Opposite direction for parallax
                const bgMouseY = -mouseOffsetY * 20;  // Less vertical movement
                
                // Apply mouse parallax (combines with tilt parallax if active)
                const currentBgX = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--bg-offset-x')) || 0;
                const currentBgY = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--bg-offset-y')) || 0;
                
                if (!this.interactivityState.tilt) {
                    // If tilt is off, use only mouse parallax
                    document.documentElement.style.setProperty('--bg-offset-x', `${bgMouseX}px`);
                    document.documentElement.style.setProperty('--bg-offset-y', `${bgMouseY}px`);
                }
                
                // üîÑ COUNTER-ROTATION: Keep object in "world space"
                const mouseCounterX = -mouseOffsetY * 15;  // Vertical mouse -> X rotation
                const mouseCounterY = -mouseOffsetX * 15;  // Horizontal mouse -> Y rotation
                
                // Update portal transform with mouse counter-rotation
                const existingScale = this.isExpanded ? 1.08 : 1.0;
                const existingZ = this.isExpanded ? 30 : 0;
                
                // Combine mouse and tilt if both active
                let totalRotX = mouseCounterX;
                let totalRotY = mouseCounterY;
                
                if (this.interactivityState.tilt) {
                    const betaNorm = Math.max(-90, Math.min(90, this.deviceOrientation.beta));
                    const gammaNorm = Math.max(-90, Math.min(90, this.deviceOrientation.gamma));
                    totalRotX += -betaNorm * 0.3;
                    totalRotY += -gammaNorm * 0.3;
                }
                
                this.portalWindow.style.transform = `
                    perspective(1000px)
                    rotateX(${totalRotX}deg)
                    rotateY(${totalRotY}deg)
                    scale(${existingScale})
                    translateZ(${existingZ}px)
                `;
                
                // üåê SUBTLE 4D PERSPECTIVE: Mouse creates different viewing angles
                const mouse4DScale = 0.15; // Very subtle 4D changes
                
                const mouse4DPerspective = {
                    // Mouse movement subtly changes which 4D slice we see
                    rot4dXW: this.baseRotations.rot4dXW + (mouseOffsetY * mouse4DScale),
                    rot4dYW: this.baseRotations.rot4dYW + (mouseOffsetX * mouse4DScale),
                    rot4dZW: this.baseRotations.rot4dZW,
                    
                    // Slight morph based on distance from center (like focal depth)
                    morphFactor: (this.params.morph || 1) + 
                               (Math.sqrt(mouseOffsetX*mouseOffsetX + mouseOffsetY*mouseOffsetY) * 0.05)
                };
                
                // If device tilt is active, combine the effects
                if (this.interactivityState.tilt) {
                    const betaNorm = Math.max(-90, Math.min(90, this.deviceOrientation.beta));
                    const gammaNorm = Math.max(-90, Math.min(90, this.deviceOrientation.gamma));
                    const alpha = this.deviceOrientation.alpha;
                    
                    mouse4DPerspective.rot4dXW += (betaNorm * Math.PI / 180 * 0.1);
                    mouse4DPerspective.rot4dYW += (gammaNorm * Math.PI / 180 * 0.1);
                    mouse4DPerspective.rot4dZW += (alpha * Math.PI / 180 * 0.05);
                }
                
                // Apply subtle 4D transformations
                this.visualizers.forEach(visualizer => {
                    if (visualizer.updateParameters) {
                        visualizer.updateParameters(mouse4DPerspective);
                    }
                });
            }
            
            toggleFullscreen() {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen();
                } else {
                    document.exitFullscreen();
                }
            }
            
            render() {
                // Get audio level if available
                let audioLevel = 0;
                if (this.audioReactive && this.audioAnalyser && this.audioData) {
                    this.audioAnalyser.getByteFrequencyData(this.audioData);
                    audioLevel = Array.from(this.audioData).reduce((a, b) => a + b, 0) / (this.audioData.length * 255);
                }
                
                // Render all VIB34D engine layers
                this.visualizers.forEach(visualizer => {
                    if (visualizer.render) {
                        visualizer.render();
                    }
                });
            }
            
            startRenderLoop() {
                const renderFrame = () => {
                    this.render();
                    requestAnimationFrame(renderFrame);
                };
                renderFrame();
            }
            
            parseUrlParameters() {
                const params = new URLSearchParams(window.location.search);
                
                // Enhanced parameter parsing with better fallbacks and normalized names
                const parsedParams = {
                    system: params.get('system') || 'faceted', // Default to faceted, not quantum
                    name: params.get('name') || 'Portal View',
                    
                    // Support both normalized (saved) and original parameter names
                    geometryType: parseInt(params.get('geometryType') || params.get('geometry')) || 0,
                    density: parseFloat(params.get('density') || params.get('gridDensity')) || 15,
                    morph: parseFloat(params.get('morph') || params.get('morphFactor')) || 1,
                    speed: parseFloat(params.get('speed')) || 1,
                    chaos: parseFloat(params.get('chaos')) || 0.2,
                    hue: parseFloat(params.get('hue')) || 200,
                    saturation: parseFloat(params.get('saturation')) || 0.8,
                    intensity: parseFloat(params.get('intensity')) || 0.8,
                    
                    // 4D rotation parameters
                    rot4dXW: parseFloat(params.get('rot4dXW')) || 0,
                    rot4dYW: parseFloat(params.get('rot4dYW')) || 0,
                    rot4dZW: parseFloat(params.get('rot4dZW')) || 0,
                    dimension: parseFloat(params.get('dimension')) || 3.5
                };
                
                console.log('üîç Parsed URL parameters:', parsedParams);
                return parsedParams;
            }
            
            updateInfoDisplay() {
                const geometryNames = ['Tetrahedron', 'Hypercube', 'Sphere', 'Torus', 'Klein Bottle', 'Fractal', 'Wave', 'Crystal'];
                
                document.getElementById('systemType').textContent = `System: ${this.params.system.toUpperCase()}`;
                document.getElementById('geometryInfo').textContent = `Geometry: ${geometryNames[this.params.geometryType] || 'Unknown'}`;
                document.getElementById('configInfo').textContent = `Config: ${this.params.name}`;
            }
        }
        
        // Initialize portal engine when page loads
        document.addEventListener('DOMContentLoaded', () => {
            new PortalEngine();
        });
    </script>
</body>
</html>